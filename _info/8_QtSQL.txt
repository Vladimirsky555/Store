QSqlDatabase db = QSqlDatabase::addDatabase("QPSQL", "MyDataBase" );
qpsql - тип базы данных
MyDataBase - имя подключения
odbc и т.д.

Подключений может быть несколько
Если имя не укажем, будет считаться главным подключением
Это сделано чтобы подключение было бы доступно из любой части программы
В дальнейшем мы будем указывать какое подключение мы используем
Кутешный драйвер не может подключить библиотеку
Ему недоступны разделяемые библиотеки
Статические библиотеки ему доступны, так как программа скомпилировалась
Но недоступны динамические библиотеки
Он говорит, что драйвер недоступен.

intl.dll
libeay32.dll
libpq.dll
ssleay32.dll

КУРСОР:
QSqlQuery - пример курсора в Qt. Объект класса QSqlQuery , который посылает команду в базу и считывает её результат.

Курсоры бывают клиентскими и серверными. Клиентский курсор. Считывает данные. Мы работаем с клиентскими курсорами
Курсоры бывают:

DINAMIC - динамический
STATIC - статический
FORWARD ONLY

Qt поддерживает все 3 курсора. По умолчанию любой курсор является динамический

Разница в чём?
Сервер возвращает результирующее множество.
Мы переберем запись за записью и получим их все.
Динамический курсор обладает особенностью.
Послали мы запрос к базе. И в какой-то момент мы курсор закрывает.
В Qt курсор закрывается командой qry.close();
Но чаще всего курсор не закрывают, а уничтожают переменную. Например забрать в дополнительный блок:
- выделение ресурса есть инициализация

* Динамический курсор всё время общается с сервером в двустороннем режиме. Он постоянно посылает запрос не изменилось ли чего. Он постоянно запрос посылает на сервер до тех пор пока мы не оставим его или сервер не отключится. 
Динамический курсор работает медленно и перегружает сеть. Без необходимости этим курсором лучше не пользоваться.  Он нужен если мы просматриваем данные запроса на экране. Но это скорее исключение нежели правило.

* Статический курсор работает также как динамический, но не предупреждает, что данные изменились. 
Статический курсор не сигнализирует. Не грузит сеть, не тормозит, работает быстро.
Но хранит в памяти всё результирующее множество, потому что позволяет просматривать как угодно

* FORWARD_ONLY позволяет просмотреть результирующее множество только лишь один раз. Потом еще один запрос нужно делать, чтобы просмотреть. Самый быстрый курсор. Зачастую, когда мы подключаемся к БД нам необходим курсор FORWARD ONLY
qry.setForwardOnly(true); - включаем курсор
Функция exec() устанавливает курсор перед первой записью результирующего множества.

qry.next() - возвращает true если ей удаётся считать запись





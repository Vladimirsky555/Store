Базовым для всех представлений является класс 
AbstractItemView - 
непосредственно используется редко
Мы имеем дело с его производными

1) Выбор элемента
2) Фокус ввода - какой элемент отредактирует на нажатие клавиши

currentIndex() - свойство. Его значением элемент, на который стоит фокус ввода. Если элемент не выбран, то функция возвратит пустой индекс

setModel() - связка представления с моделью

setSelectionBehavior() - каким именно образом выбираются элементы.
- индивидуально
- по строкам (выбираем строку)
- по столбцам

setSelectionModel()
- нет выбора
- ячейки выбираются строго по одной
- можем выбрать группу смежных ячеек
- выбираем произвольное количество ячеек, удерживая клавишу ctrl
- выбор и снятие ячеек делается отдельная операция. Пока руками не снимем, будет выбрана
В таком случае нужно предусмотреть кнопку сброса выбора. Если у нас автоматический сброс выбора не производится. 
Настраивать такой режим нежелательно, но иногда пользователь может попросить.

setSelection() - позволяет программно выбрать какую-то группу элементов

selectedIndexes() - перечен всех выбранных элементов. В модели множественный выбор. Перечень выбранных элементов задаётся таким образом. 

Сигналы:
activated() -мы активировали элемент (двойной щелчёк)
Элемент активирован в не зависимости как это сделано
entered() - на данный элемент представления перемещён фокус ввода клавиатуры
cliked() - одинарный щелчёк
doubleClicked() - двойной щелчёк
viewportEntered() - фокус ввода клавиатуры перемещён на виджет.
Классы представления это виджеты. Они кладутся на форму.
Классы модели виджетами не являются.
pressed() - нажата клавиша клавиатуры какая-то

Основные предствления это
QListView
QTableView
QTreeView

QHeaderView - вспомогательный класс
QColumnView - используется, но не очень часто

Создавая собственный класс модели. Но мы зачастую пользуемся стандартным классом. Нам не нужно к нему ничего добавлять. Если и нужно, то примитивное.

QTableView - это таблица
Шапка и боковина этого представления представлены классом QHeaderView

horizontalHeader() - возвращает представление отвечающее за шапку таблицы
verticalHeader() - возвращает предстввление отвечающее за боковину таблицы
- скрыть и показать строку

gridStyle() - как показать разграфку таблицы
showGrid() - управлять гридами
setWordWrap() - как показать текст ячейки, в одну строчку или можно разместить на нескольких строчках 
rowAt(),columnAt() - указываем точку в пикселях, и она возвращает номер строки, на которую мы щёлкнули мышкой

hideColumn(), hideRow() - скрыть и показать колонки

resizeRowToContents(),resizeRowsToContent(),resizeColemtToContent(),resizeColumnsToContent() - изменять ширину и высоту колонок и строк

currentChanged() - когда мы выбираем элемент, снимаем фокус ввода с одного элемента на другой. 


QListView
Отличие спискового представления от табличного в том, что списковое представление показывает нам файлы в файловой системе.  
Списковое представление может переключаться, имеет дополнительный параметр "вид"
Мы можем посмотреть на список, переключить его в режим значков. 

И список и таблица показывают нам элементы одного уровня. Дочерние элементы не будут показаны. 
Но у класса AbstractItemView есть важная функция, общая для всех моделей:
setRootIndex() - мы можем объявить корневым какой-то элемент модели. Табличное и списковое представление покажут нам семейство дочерних элементов от данного. 
Пример: При клике на папку показывается её содержимое, а не сама папка
Древовидное представление покажет нам данный элемент и всё дерево, которое под ним расположено.

Древовидную модель можно просматривать представлением любого вида. 

QColumnView - полезен при редактировании настроек и свойство
Преображает модель в последовательность колонок. Выбираем элемент, он показвыает дочерние элементы в другой колонке. 
Бывает полезно при редактировании адресов (город, список улиц, список домов, список квартир, список жильцов) - очень облегчает разработку программы.

КЛАССЫ-ДЕЛЕГАТЫ:

itemDelegate()
itemDelegate(QModelIndex &index)
itemDelegateForColumn(int column)
itemDelegateForRow(int row)

Делегат отвечает за нестандартное редактирование, или нестандартное представление

Установить, зарегистрировать делегата, экземпляр делегата мы можем для всего представления целиком - itemDelegate()

itemDelegate(QModelIndex &index) - регистрация делегата для элемента модели

itemDelegateForColumn(int column) - для колонки

itemDelegateForRow(int row) - для строки

Таблица растёт сверху вниз, поэтому itemDelegateForColumn(int column) используется чаще

Сами классы делегатов
QAbstractItemDelegate()
Паттерн проектирования - factory (фабрика)
Объект, который используется для других объектов.
Чтобы создать экземпляр некоего класса не вызываем конструктор, а вызываем метод какого-то другого объекта.

Конечно конструктор там вызывается в глубине.

Каждая разновидность делегата предназначена для определенных целей. 
Для создания собственных делегатов используется
1) QAbstractItemDelegate()
2) QItemDelegate() - редактируем элементы строго по одному 

Важнейшие функции:
createEditor(); - cоздание виджета для редактирования элемента
destroyEditor();
setEditorData() - перенос данных с модели на редактор
setModelData() - перенос данных с эдитора в модель
paint() - нестандартное отображение элемента

3)QSqlRelationalDelegate() - заполнение ячейки из одной таблицы данными из другой










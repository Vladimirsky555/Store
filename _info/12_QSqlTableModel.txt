QSqlQueryModel непригодная для редактирования, но идеально подходит для просмотра данных в таблице.

QSqlTableModel настраивается на конкретную таблицу. Позволяет получить доступ к данным конкретной таблицы и эту конкретную таблицу редактировать.

QSqlTableModel - не умеет нормально применять фильтры
Редактирование данных в таблице БД - вещь опасная

Редактирование:
Если редактировать данные напрямую в базе данных, то кто-то может их считать в процессе редактирования.
Также огромный поток данных на нас выльется, среди которых нам нужно будет искать что редактировать.
Поэтому - 
Выборку, которую мы собираемся редактировать мы запишем во временную таблицу. После этого мы откроем временную таблицу и будем работать с ней как обычно.
Временная таблица предписывается к конкретному соединению с базой.
Два пользователя подключатся к базе и создадут одинаковые таблицы с одинаковыми именами, то это допустимо.
Эти две таблицы будут работать независимо друг от друга. 
Если один и тот же пользователь подключится дважды, то таблица предыдущего соединения будет не видна. Значит мы можем создавать временных таблиц сколько угодно
Проблема в том, что у нас должно быть право на создание временной таблицы.
В PostgreSql мы можем создать спецсхему для временных таблиц. 
Но это относится к работе с PostgreSql.

      //    "cteate temporary table my_books as \n"
      //    "cteate table my_books as           \n"
     //     "cteate temp table my_books as     \n"
            "SELECT                            \n"
            "    b.iid,                        \n"
            "    b.rid_catalogue,              \n"
            "    b.author,                     \n"
            "    b.title,                      \n"
            "    b.year,                       \n"
            "    b.location,                   \n"
            "    b.pablisher,                  \n"
            "    b.pages,                      \n"
            "    b.annote,                     \n"
            "    b.rid_status,                 \n"
            "    s.title,                      \n"
            "    b.acomment                    \n"
            "FROM books b                      \n"
            "left outer join status s         \n"
            "     on b.rid_status = s.iid     \n"
            "WHERE b.rid_catalogue = :CID     \n";

Эта таблица - результат запроса. Типы колонок будут определены автоматически. Возможно придется добавить ещё одно поле, так как нам нужно отслеживать какие данные изменены, а какие не изменены. Так как сохранять в базу обратно нужно только те данные, которые изменены. 
Не стоит сохранять данные, которые мы не меняли, вдруг его отредактировал кто-то другой. 

Временная таблица автоматически сбрасывается, когда мы отключаемся от базы. Если мы не отключаемся, то таблица существует.
Чтобы это корректно сработало, нужно прибить табличку. 


Во временную таблицу можно складывать измененные записи.			


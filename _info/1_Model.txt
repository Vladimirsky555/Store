Устройство модели:

AbstractItemModel - Базовый класс для всех моделей

Группа свойств самого элемента:
1) Данные data()
Семейство данных для элемента:
- шрифт
- цвет
- сам текст

1.1) Роль
User role - речь идёт о роли, которую пользователь может использовать по своему усмотрению. 

Данные в модели нигде не сохраняются.
Функция data() получает индекс элемента
role, какая требуется, возвращает данные.
часть данных вычисляется, часть данных берется из какого-то источника (база данных)

2) Свойство flags - флаги:
- доступен для чтения 
- доступен дял чтения и редактирования
- разрешён ли выбор данного элемента

Флаги вычисляются каждый раз.

3) Внешнее свойство - parent

4) Индекс (QModelIndex)
- Номер строки
- Номер столбца
Индекс элемента в модели задаётся относительно родителя

Все элементы равноправны между собой.
каждый элемент может быть родителем для других элементов

Модель в Qt имеет древовидную структуру
Номер столбца равен 0, получается списочная структура

Важные функции:
Элемент модели:
data(); - вычисление данных соответствующей роли
ItemData() - выдаёт все данные модели
flags() - вычисляем флаги элемента по индексу

Сама модель:
columnCount() - кол-во столбцов под родителем
rowCount() - количество строк под родителем
index() - вычисляет индекс того элемента, который находится под родителем в заданном столбце, заданной строки
parent() - возвращает родителя по элементу
sibling() - выдает элемент заданой строки, заданного столбца того же родителя - брат
setData() - вызывает тогда, когда хотим изменить значение массива данных заданного элемента (редактирование)


Сигналы: 
modelReset() - важнейший сигнал
Сигнал, который означает, что данные в модели изменились
Все представления, подключенные к модели, должны обновить данные в принудительном порядке

dataChanged() - то же самое, но подаёт сигнал об изменении диапазона
Те представления, которые показывают на экране данные должны обновиться

modelAboutToBeReset() - заставляет все связанные с моделью представления прекратить обновление данных.
При изменении данных их обновление - пустая трата времени

Функция:
headerData() - если мы имеем дело с табличной моделью, то у таблицы есть заголовок, шапка и боковина таблицы.
Данные шапки и боковины задаются тоже в модели, несмотря на то, что являются элементами представления.
По умолчанию эти данные являются данными модели.

QAbstractListModel, 
QAbstractProxyModel, 
QAbstractTableModel, 
QConcatenateTablesProxyModel, 
QDirModel, 
QFileSystemModel, 
QStandardItemModel


QStandartItemModel - делает ряд предположений относительно структуры нашей модели, например вставка строки,
вставка столбца
Взять за основу этот класс полезно

Более интересен класс 
QAbstractTableModel - создааёт модель табличного типа.
Организует элементы в таблицу
Формирует обычную таблицу. 
Элементов дочерних нет. Если есть, то этот класс не подходит, нужны другие классы.

QSqlQueryModel - 
показывет на экране исполнение команды SELECT
Фиксированное число колонок и растёт сверху вниз
Изначально работает в режиме чтения
Можно и запись, но это редко кто делает.
Как исправлять данные в базе?

QSqlTableModel - 
подключается к конкретной таблице базы данных
Является моделью read-write
Заковыка: дело в том, что исправлять данные в таблице базы данных является ошибкой в современной модели. 
Если мы берём таблицу базы данных и правим там данные, то в реляционном походе к БД это является ошибкой. Почему?
Дело в том, что любые правки базы данных обёрыватся в транзакции. Начинаются с 
begin transaction
Далее действия
commit transaction
Данные сохранятся, либо 
rollback - откат транзакции
Исправления в базе делают группами. 
То есть нужно начать транзакцию, потом либо commit или rollback.
Но это пример длинной транзакции. 
По факту это приводит к ошибке. 
При помощи класса QSqlTableModel можно решить ряд проблем, которые без него невозможно.
1) Редактирование с точки зрения пользователя - изменение в таблице. 
2) Пользователю нужно редактировать не все данные, а фрагмент
Как правило этот класс используется для просмотра представления, используется вместо класса QSqlQueryModel.
Если нам необходимо только чтение, то класс QSqlTableModel упрощает эту задачу
Нет ошибки:
1) Временная таблица.
Пользователь создаёт временную таблицу. Нет транзакций. Кроме пользвателя таблицу никто не видит.
Нажимая одну кнопку, данные сохраняются в основную, а временную убивают. Это вариант, как можно выполнить редактирование.
Во временную таблицу можно сохранить часть данных
2) Вспомогательная таблица. Временная располагается на том же сервере, в той же базе данных. Сформирована как нам хочется или на базе представления.
Она находится за пределами БД, за пределами сервера. Она располагается на клиентской стороне. Мы перекачиваем редактируемые данные на клиента, редактируем, а потом закачиваем обратно.
Вспомогательная таблица более полезна тогда, когда между клиентом и сервером связь нестабильная. 
Мы перекачиваем полностью данные к нам, редактируем, перекачиваем обратно.
При временной таблице мы на каждый чих обращаемся к серверу. По каждой ячейке летит запрос в таблицу. 
Если связь нестабильная, то у нас на клиете данные сохранены. Как связь появится, данные мы отправим на сервер.
QSqlTableModel - класс чрезвычайно полезный. 



QAbstractListModel - абстрактная модель списка.
Даёт одномерный линейный список чего-нибудь. 
EnginioModel - предназначена для работы с облаком Qt.
QStringListModel - упрощённый вариант QAbstractListModel - когда наши элементы просто набор некоторых текстов. 
Главным образом применяется в сочетании с Combobox. 


QAbstractProxyModel - модель которая встраивается между какой-то другой моделью и нашей таблицей и предоставляет в нашу таблицу данные из другой модели в каком-то видоизмененном виде. 
QSortFilterProxyModel - самый обсуждаемый класс.
Показывает данные другой модели в отсортированном виде.
Как правило сортировка делается средствами базы данных. 
Редко когда мы пытаемся получить все данные запроса, как правило первые 100 строк, первую 1000, но не первый миллион. 
Но если данных немного и нужно пересортировать на ходу, то эта модель может пригодиться. 


QFileSystemModel - редко, но метко
Модель, которая позволяет просматривать файловую систему, представляет образ файловой системы.
Показывает всё содержимое файловой системы. Какую-то папку мы объявляем корневой точкой и в представлении будет показана модель от этой отправной точки. 
Эта модель интересна тем, что она одинаково часто применяется с представлением, так и сама по себе, просто как источник данных.
Для этой модели правило: она может использоваться в качестве источника данных без представления, как и с представлением. 



